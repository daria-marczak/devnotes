# Testing React applications with Jest

## Regression
One person adds a new features which improves some views. They are now correct. Another person modifies the new feature but is not aware of breaking effects on a feature. Their view looks good so dev commits changes what causes the another view to regress to unintended state. Tests help as they will fail and we can see what has been done.

## Types of tests
|Type|What it tests|Required tools|
|:---|:------------|:-------------|
|Unit test|A single function or service|Mocha / Jest|
|Component Test|A single component (functionality)|Jest / Enzyme|
|Snapshot|A single component (regression)|Jest|
|End-to-End test|Interaction between multiple components|Protractor / Cypress|

### Unit tests
+ Verifies the functionality of a class or methos
+ Simplest to write and execute
+ Used to test correctnes of application logic
+ Tests can be written prior to application (Test Driven Development)

### Component tests
+ Verifies the correct appearance and functionning of a component
+ Highly sensitive to small changes to underlying components and services
+ Provides a strong defense against regression
+ Verifies changes to component output in response to change in application state
+ Does not verify interactions between two components

### Snapshot tests
+ A subtype of component tests
+ Automatically generated by Jest
+ Verifies output matches pas record
+ Tends to fail if even the slightest change occurs

### Performance tests
+ Measure how long a block of code takes to execute
+ Can identify bottlenecks in application performance
+ Can provide insight into performance differences on different devices and cloud

### Coverage tests
+ A test for your tests
+ Measures application code which is visited (but not necessarily verified) during tests
+ Does not indicate whether application works or not, but it is nice to have

### End-to-End tests
+ Measures the functionality of the whole app
+ Often executed in a virtual or “headless” browser
+ Creates a scenario to test by simulating user actions
+ Different in nature and more difficult to write than other tests
+ Provide the best assurance that the app works

## Jest
+ A library installed via npm or yarn and run via the command line
+ Similar to popular test-runners but with handy extra features
+ A tool made by a team including members of React team
+ Adds snapshot testing, mocking and many other useful features
+ Includes superior assertion library, CLI
+ Works with or without React

### Jest testing ecosystem
+ Enzyme
+ Jasmine / Mocha (Jest is built on top of it)

#### Jasmine / Mocha
+ Test-runners that organizes tests into "describe" and "it" blocks (or "suite" and "test")
+ All assertions inside test are verified whenever the test-runner is invoked, e.g. with command line
+ Doesn't include mocking or snapshots

#### Enzyme
+ Not a test runner like Jest, but provides tools to test React apps specifically
+ Expresses component output as HTML (like React test renderer)
+ Potentially useful but not for every project

### Jest vs Mocha
|Function|Jest|Mocha|
|:-------|:---|:----|
|Runs tests|Yes|Yes|
|Asynchronous|Yes|Yes|
|Spies included|Yes|No|
|Snapshot testing|Yes|No|
|Module mocking|Yes|No|


### Jest CLI
A tool that we use to run Jest from the command line and provides configuration options to Jest

Test files can be named either **.spec.js* or **.test.js*

#### Tests in their own folder
|Test in their own folder|Test alongside components|
|:-----------------------|:------------------------|
|Easily distniguish between test and non-test files|Which files are components and which files are spec is not as obvious|
|Unrelated files can share a folder (i.e. a "loginService" test and a "cryptoHash" test|Tests are always adjacent to the files they apply to|
|Very easy to isolate a prticular set of tests that are in the same folder|Unrelated tests are less likely to share a folder|
|Tests can be named anything but must be inside an appropriately named folder (i.e. __ tests __), to be recognized|Tests must have a correct naming pattern to be recognized, i.e. *.test.js |
||Possible to isolate tests based on name paterns, i.e., user-*|

### Jest globals
+ It (test) – method which you pass a function to, that function is executed as block of tests by the test runner
+ Describe (suite) – an optional method for grouping any number of it statements

### Skipping and isolating tests
+ Skipping a test results in that test not being run
+ Isolating a test results in only it (and any other isolated tests) running

```
    it.only("should be isolated", () => {
        ...code
    });
    
    it.skip("should be skipped", () => {
        ... code
    });
```

### Asynchronous tests
+ Contains assertions (just like a regular test)
+ Does not complete instantaneously
+ Can take varying amounts of time, even an unknown amount of time
+ Jest must be notified that test is complete

#### Defining asynchronous test
+ Invoke the done() callback that is passed to the test
```
    it("async test", done => {
        setTimeout(done, 100);
    });
```
+ Return a promise from a test
```
    it("async test",() => {
        new Promise() (
            resolve => setTimeout(resolve, 100);
        );
    });
```
+ Pass an async function to describe (the cleanest syntax)
```
    it("async test", async () => awair delay(100));
```

## Jest mocks
+ Reduces dependencies required by tests (faster execution)
+ Prevents side-effects during testing
+ Facilitates desired testing procedure

### Mock
+ A convincing duplicate of an object with no internal workings
+ Can be automatically or manually created
+ Has same API as original, but no side-effects
+ Spies and other mock features simplify testing

### Mocking process
1. Scan the original object for methods, give the new object spy methods with the same names
2. Esnure that any methods which returned a promise still return a promice in the mock
3. Create mocks for any complex values that are returned from methods which are reauired for tests

### Mock functions 
Also known as spies, as they give an insight on how the method is interacted with. They create no side-effects. Spies count function calls. It also records what arguments are passed in. We can load the function up with return values. The new value must be approximately original.

### Creating mock files
The mock has to be named appropriately, as NPM mocks are loaded automatically. Mocks must reside in __ mocks __ folder next to mocked module. NPM modules and local modules can both be mocked. 

### Manual mocks vs automatic ones
|Manual mocking|Automatic mocking|
|:-----------------------|:------------------------|
|Exists as a separate file alongside the file being mocked|Most modules can be automatically replaced with mocks|
|Manual mocks will be used automatically for NPM modules|Mocks are usually generated correctly, but sometimes not|
|Manual mocks are more work than automatic mocks|Greatly reduced likelihood of side-effects during tests|
|Needs to be updated when mocked file changes|Developer must use discretion |

#### Automated mocking challenges
+ Methods returning a specific and complex value often can't be mocked automatically
+ Methods that are not part of your module at compile-time won't be mocked
+ Modules that you did not expect to be mocked may be mocked


## Snapshot testing
A snapshot is a JSON file: it's a record of a component's output. Jest compared it to component's actual output during testing process. It's comitted along with other modules and tests to the application repo.

To create a snapshot we need to import the component and renderer from react-test-renderer. We use ``renderer.create`` to create a tree, which is a representation of HTML output of the component. In this example enzyme is not used.

We then need an assertion ``toMatchSnapshot()``. However, the first time it's called, it just creates a snapshot, it has nothing to compare it to. Nothing is being tested. But once the file with JSON exists, it compares the representation.

``expect(tree.toJSON()).toMatchSnapshot()`` is the full method that we need to call to create a snapshot.

### Snapshot testing process
1. Creation of a new component
1. Snapshot is generated automatically
1. Commit of changes
1. Other person makes a change to a dependency of the component
1. A new snapshot is automatically generated
1. Test suite sees that the snapshots don't match so it fails until will be updated (if the change was intended, they can update the snapshot)

