# Testing React applications with Jest

## Regression
One person adds a new features which improves some views. They are now correct. Another person modifies the new feature but is not aware of breaking effects on a feature. Their view looks good so dev commits changes what causes the another view to regress to unintended state. Tests help as they will fail and we can see what has been done.

## Types of tests
|Type|What it tests|Required tools|
|:---|:------------|:-------------|
|Unit test|A single function or service|Mocha / Jest|
|Component Test|A single component (functionality)|Jest / Enzyme|
|Snapshot|A single component (regression)|Jest|
|End-to-End test|Interaction between multiple components|Protractor / Cypress|

### Unit tests
+ Verifies the functionality of a class or methos
+ Simplest to write and execute
+ Used to test correctnes of application logic
+ Tests can be written prior to application (Test Driven Development)

### Component tests
+ Verifies the correct appearance and functionning of a component
+ Highly sensitive to small changes to underlying components and services
+ Provides a strong defense against regression
+ Verifies changes to component output in response to change in application state
+ Does not verify interactions between two components

### Snapshot tests
+ A subtype of component tests
+ Automatically generated by Jest
+ Verifies output matches pas record
+ Tends to fail if even the slightest change occurs

### Performance tests
+ Measure how long a block of code takes to execute
+ Can identify bottlenecks in application performance
+ Can provide insight into performance differences on different devices and cloud

### Coverage tests
+ A test for your tests
+ Measures application code which is visited (but not necessarily verified) during tests
+ Does not indicate whether application works or not, but it is nice to have

### End-to-End tests
+ Measures the functionality of the whole app
+ Often executed in a virtual or “headless” browser
+ Creates a scenario to test by simulating user actions
+ Different in nature and more difficult to write than other tests
+ Provide the best assurance that the app works

## Jest
+ A library installed via npm or yarn and run via the command line
+ Similar to popular test-runners but with handy extra features
+ A tool made by a team including members of React team
+ Adds snapshot testing, mocking and many other useful features
+ Includes superior assertion library, CLI
+ Works with or without React

### Jest testing ecosystem
+ Enzyme
+ Jasmine / Mocha (Jest is built on top of it)

#### Jasmine / Mocha
+ Test-runners that organizes tests into "describe" and "it" blocks (or "suite" and "test")
+ All assertions inside test are verified whenever the test-runner is invoked, e.g. with command line
+ Doesn't include mocking or snapshots

#### Enzyme
+ Not a test runner like Jest, but provides tools to test React apps specifically
+ Expresses component output as HTML (like React test renderer)
+ Potentially useful but not for every project

### Jest vs Mocha
|Function|Jest|Mocha|
|:-------|:---|:----|
|Runs tests|Yes|Yes|
|Asynchronous|Yes|Yes|
|Spies included|Yes|No|
|Snapshot testing|Yes|No|
|Module mocking|Yes|No|


### Jest CLI
A tool that we use to run Jest from the command line and provides configuration options to Jest

Test files can be named either **.spec.js* or **.test.js*

#### Tests in their own folder
|Test in their own folder|Test alongside components|
|:-----------------------|:------------------------|
|Easily distniguish between test and non-test files|Which files are components and which files are spec is not as obvious|
|Unrelated files can share a folder (i.e. a "loginService" test and a "cryptoHash" test|Tests are always adjacent to the files they apply to|
|Very easy to isolate a prticular set of tests that are in the same folder|Unrelated tests are less likely to share a folder|
|Tests can be named anything but must be inside an appropriately named folder (i.e. __ tests __), to be recognized|Tests must have a correct naming pattern to be recognized, i.e. *.test.js |
||Possible to isolate tests based on name paterns, i.e., user-*|

### Jest globals
+ It (test) – method which you pass a function to, that function is executed as block of tests by the test runner
+ Describe (suite) – an optional method for grouping any number of it statements

### Skipping and isolating tests
+ Skipping a test results in that test not being run
+ Isolating a test results in only it (and any other isolated tests) running

```
    it.only("should be isolated", () => {
        ...code
    });
    
    it.skip("should be skipped", () => {
        ... code
    });
```

### Asynchronous tests
+ Contains assertions (just like a regular test)
+ Does not complete instantaneously
+ Can take varying amounts of time, even an unknown amount of time
+ Jest must be notified that test is complete

#### Defining asynchronous test
+ Invoke the done() callback that is passed to the test
```
    it("async test", done => {
        setTimeout(done, 100);
    });
```
+ Return a promise from a test
```
    it("async test",() => {
        new Promise() (
            resolve => setTimeout(resolve, 100);
        );
    });
```
+ Pass an async function to describe (the cleanest syntax)
```
    it("async test", async () => awair delay(100));
```

## Jest mocks
+ Reduces dependencies required by tests (faster execution)
+ Prevents side-effects during testing
+ Facilitates desired testing procedure

### Mock
+ A convincing duplicate of an object with no internal workings
+ Can be automatically or manually created
+ Has same API as original, but no side-effects
+ Spies and other mock features simplify testing

### Mocking process
1. Scan the original object for methods, give the new object spy methods with the same names
2. Esnure that any methods which returned a promise still return a promice in the mock
3. Create mocks for any complex values that are returned from methods which are reauired for tests

### Mock functions 
Also known as spies, as they give an insight on how the method is interacted with. They create no side-effects. Spies count function calls. It also records what arguments are passed in. We can load the function up with return values. The new value must be approximately original.

### Creating mock files
The mock has to be named appropriately, as NPM mocks are loaded automatically. Mocks must reside in __ mocks __ folder next to mocked module. NPM modules and local modules can both be mocked. 

### Manual mocks vs automatic ones
|Manual mocking|Automatic mocking|
|:-----------------------|:------------------------|
|Exists as a separate file alongside the file being mocked|Most modules can be automatically replaced with mocks|
|Manual mocks will be used automatically for NPM modules|Mocks are usually generated correctly, but sometimes not|
|Manual mocks are more work than automatic mocks|Greatly reduced likelihood of side-effects during tests|
|Needs to be updated when mocked file changes|Developer must use discretion |

#### Automated mocking challenges
+ Methods returning a specific and complex value often can't be mocked automatically
+ Methods that are not part of your module at compile-time won't be mocked
+ Modules that you did not expect to be mocked may be mocked


## Snapshot testing
A snapshot is a JSON file: it's a record of a component's output. Jest compared it to component's actual output during testing process. It's comitted along with other modules and tests to the application repo.

To create a snapshot we need to import the component and renderer from react-test-renderer. We use ``renderer.create`` to create a tree, which is a representation of HTML output of the component. In this example enzyme is not used.

We then need an assertion ``toMatchSnapshot()``. However, the first time it's called, it just creates a snapshot, it has nothing to compare it to. Nothing is being tested. But once the file with JSON exists, it compares the representation.

``expect(tree.toJSON()).toMatchSnapshot()`` is the full method that we need to call to create a snapshot.

### Snapshot testing process
1. Creation of a new component
1. Snapshot is generated automatically
1. Commit of changes
1. Other person makes a change to a dependency of the component
1. A new snapshot is automatically generated
1. Test suite sees that the snapshots don't match so it fails until will be updated (if the change was intended, they can update the snapshot)

Snapshot tests are actually showing what does not match the snapshot taken of the component.

### Advantages and disadvantages

|Advantages|Disadvantages|
|:---------|:------------|
|Fast and automatic|Easy to ignore and suppress|
|Catches regressions humans may miss|Protects only against regression|
|Works nicely with libraries that take in state and output HTML components (React, Angular, Vue)|If a component is working incorrectly and then is fixed, a snapshot test will say it is now broken|
|Adds some protection against regression when no time is available for manually writing tests|Adds extra files to an already crowded repo|
|Requires little training or knowledge of testing to use|Sensitive to incidental changes|
||A waste of resources, if component is certain to be modified in near future|

### Updating snapshot
If we made a meaningful change to a test and we want to update the snapshot, we should use ``-u`` standing for update.

## Building testable React components
+ No internal state – output is an idempotent product of the props that are provided
+ No side-effects – any AJAX calls, UI changes or other side effects are hadnled by sagas, thunks, etc., but not by components
+ No lifecycle hooks – fetching data is handled on the application level, not the component level

## React-Redux and Jest
+ Components don't generate side effects
+ Component consists of logical display and container components
+ Components do not have internal state

### How to test?
+ Test container and display elements separately
+ Use unit tests to verify methods and properties passed by container are accurate
+ Use snapshot tests to verify the output of the display component, passing props in directly

### React-test-renderer vs. Enzyme
|React-test-renderer|Enzyme|
|:------------------|:-----|
|Takes a React component and outputs the resulting HTML without a DOM|Takes a React component and outputs the resulting HTML without a DOM|
|From the React team|From AirBnB team|
|Useful for getting the output HTML of a component for snapshot testing|Useful for testing a variety of interactions including click, keyboard input, and more|
|Recommended by the Jest team|Has a variety of open bugs which make using it a challenge|

### Testing stateful React comopnents
+ Mock dependencies, then test them
+ Use spies to verify side-effects
+ Move logic from lifecycle to services
+ Prevent regression with snapshots
+ Inject values by writing mocks for services
+ Make stateless components, where possible

## Matcher
+ Also known as an assertion or expectation
+ It's a representation of a claim that a value will be equal (or not) to something
+ Throws an error (test fails) if matcher's claim is not equal

```
function test() {
    const value = getValue43();
    if (value !== 43) {
        throw new Error(/**/);
    }
}
```
It's  a handwritten test with an if statement. It throws an error that results in the test failing, not in the aplication failing.

```
function test2() {
    const value = getValue43();
    expect(value).toEqual(43);
}
```
Equivalent code using a matcher. It's much clearer. 

### Types
+ Not – reverses an assertion. If an assertion without not would pass, assertion with not will fail
+ To be and To Equal – Verify that two values are equivalent. Two arrays with matching elements are equal, but not identical. Very general: use more specific matcher when possible
+ To be close to – like *toEqual* for numbers, but assertion still passes if numbers are close but not equal. For assertions involing floating point numbers.
+ To contain and to have length – array matchers which verify the contents and size of a collection

